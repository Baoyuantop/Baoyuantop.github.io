<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://baoyuantop.github.io</id>
    <title>Baoyuan&apos;s Blog</title>
    <updated>2021-07-21T15:05:13.810Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://baoyuantop.github.io"/>
    <link rel="self" href="https://baoyuantop.github.io/atom.xml"/>
    <logo>https://baoyuantop.github.io/images/avatar.png</logo>
    <icon>https://baoyuantop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Baoyuan&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Rust 函数]]></title>
        <id>https://baoyuantop.github.io/post/rust-han-shu/</id>
        <link href="https://baoyuantop.github.io/post/rust-han-shu/">
        </link>
        <updated>2021-07-21T14:05:22.000Z</updated>
        <content type="html"><![CDATA[<p>定义一个两数相加的函数:</p>
<pre><code class="language-rust">fn add(a: u8, b: u8) {
    let sum = a + b;
    println!(&quot;sum is {}&quot;, sum)
}
</code></pre>
<p>如果你没有为变量声明类型，它们将设置为你第一次使用的函数的参数类型。</p>
<p>默认情况下整数的推断类型为 <code>i32</code>。</p>
<pre><code class="language-rust">let y = 12;
let z = 34;

add(y, z);
</code></pre>
<p>因为使用了 add 函数，y 和 z 将被推断为 <code>u8</code> 类型。如果再将 y 或者 z 传入其他类型参数的函数中会触发程序 panic。</p>
<pre><code class="language-rust">fn guess_number(number: i32) {
    println!(&quot;Indeed, {} is the correct answer&quot;, number)
}
</code></pre>
<pre><code class="language-rust">guess_number(z); // 需要 i32 而传入了 u8
</code></pre>
<p>需要显式类型转换:</p>
<pre><code class="language-rust">guess_number(y as i32);
</code></pre>
<h2 id="函数返回类型">函数返回类型</h2>
<pre><code class="language-rust">// 接受一个 i32 类型的参数，返回一个 i32 类型的值
fn square(number: i32) -&gt; i32 {
    number * number
    // 返回值的表达式
    // 等效于 return number * number
}
</code></pre>
<p>使用元组返回多个值：</p>
<pre><code class="language-rust">fn triple(number: i32) -&gt; (i32, i32) {
    let input = number;
    let result = number * 3;
    (input, result)
}
</code></pre>
<p>没有返回值，指定返回值为 () 是可选的。</p>
<pre><code class="language-rust">fn does_not_return() -&gt; () {
    println!(&quot;ain't returning nuthing!&quot;)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[元组类型]]></title>
        <id>https://baoyuantop.github.io/post/yuan-zu-lei-xing/</id>
        <link href="https://baoyuantop.github.io/post/yuan-zu-lei-xing/">
        </link>
        <updated>2021-07-21T06:18:52.000Z</updated>
        <content type="html"><![CDATA[<p>Tuples (元组) 类型 用于混合数据类型，最多可以有 12 种混合类型。</p>
<p>定义元组并取值:</p>
<pre><code class="language-rust">let a_tuple: (&amp;str, u8, char) = (&quot;ok&quot;, 0, 'd');
let first_item = a_tuple.0;
println!(&quot;first_item is {}&quot;, first_item); // &quot;ok&quot;
</code></pre>
<p>修改元组的值：</p>
<pre><code class="language-rust">let mut b_tuples = (&quot;ok&quot;, 0);
b_tuples.0 = &quot;ko&quot;;
b_tuples.1 += 1;
println!(&quot;b_tuples.0 is {}, b_tuples.1 is {}&quot;, b_tuples.0, b_tuples.1);
</code></pre>
<p>元组的解构赋值:</p>
<pre><code class="language-rust">let c_tuple = (&quot;zh&quot;, &quot;CN&quot;, 1);
let (language, country, code) = c_tuple;
println!(
    &quot;language is: {}, country is: {}, code is: {}&quot;,
    language, country, code
); // language is: en, country is: US, code is: 1
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vectors 类型]]></title>
        <id>https://baoyuantop.github.io/post/vectors-lei-xing/</id>
        <link href="https://baoyuantop.github.io/post/vectors-lei-xing/">
        </link>
        <updated>2021-07-19T13:30:08.000Z</updated>
        <content type="html"><![CDATA[<p>vector 是一个具有相同类型的数据集合，元素按顺序排列。</p>
<p>数组 具有固定的大小，必须在编译时确定大小，因为数组存储在栈上。</p>
<p>vector 可以动态的调整大小，通过 <code>adding</code> 或 <code>removing</code> 元素。相当于动态长度的数组。</p>
<p>vector 数据存储在堆内存中，因此你需要自己处理 <code>所有权</code> 和 <code>借用</code>。</p>
<pre><code class="language-rust">let mut letters: Vec&lt;char&gt; = vec!['a', 'b', 'c'];
println!(&quot;letters are {:?}&quot;, letters); // letters are ['a', 'b', 'c']

let first_letter = letters[0];
println!(&quot;first_letter is {}&quot;, first_letter); // first_letter is a
</code></pre>
<p>向 vector 中添加数据:</p>
<pre><code class="language-rust">letters.push('d');
letters.push('e');
letters.push('f');
println!(&quot;letters are {:?}&quot;, letters); // letters are ['a', 'b', 'c', 'd', 'e', 'f']
</code></pre>
<p>删除最后一个元素:</p>
<pre><code class="language-rust">letters.pop();
println!(&quot;letters are {:?}&quot;, letters); // letters are ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>可变的 vector：</p>
<pre><code class="language-rust">let mut numbers: Vec&lt;i32&gt; = vec![11, 22, 44];
numbers[2] = 33;
println!(&quot;numbers is {}&quot;, numbers[2]); // numbers is 33
</code></pre>
<p>获取长度:</p>
<pre><code class="language-rust">let mut ints = vec![22, 33, 44, 55, 66, 77];
let length: usize = ints.len();
println!(&quot;length is {}&quot;, length); // length is 6
</code></pre>
<p>vector 切片:</p>
<pre><code class="language-rust">let mut slice: &amp;[i32] = &amp;ints;
println!(&quot;slice is {:?}&quot;, slice); // slice is [22, 33, 44, 55, 66, 77]
slice = &amp;ints[2..5];
println!(&quot;slice is {:?}&quot;, slice); // slice is [44, 55, 66]
</code></pre>
<p>基于 vector 的迭代:</p>
<pre><code class="language-rust">for it in ints.iter() {
    println!(&quot;it is {}&quot;, it);
}

// it is 22
// it is 33
// it is 44
// it is 55
// it is 66
// it is 77
</code></pre>
<p>在迭代中修改值:</p>
<pre><code class="language-rust">for it in ints.iter_mut() {
    // 使用取消引用指针 (*it) 以获取和修改值
    *it *= *it;
}
println!(&quot;ints is {:?}&quot;, ints); // ints is [484, 1089, 1936, 3025, 4356, 5929]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[切片类型(slices)]]></title>
        <id>https://baoyuantop.github.io/post/qie-pian-lei-xing-slices/</id>
        <link href="https://baoyuantop.github.io/post/qie-pian-lei-xing-slices/">
        </link>
        <updated>2021-07-13T02:31:08.000Z</updated>
        <summary type="html"><![CDATA[<p><code>切片 (slice)</code> 用于引用一个集合（比如数组、字符串）的一段连续部分（子集）而不需要拥有这些元素的所有权。</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>切片 (slice)</code> 用于引用一个集合（比如数组、字符串）的一段连续部分（子集）而不需要拥有这些元素的所有权。</p>
<!-- more -->
<p>比较常见的用法有 字符串切片类型 <code>&amp;str</code>。</p>
<p>字符串字面量是 <code>slice</code> 类型，数据被硬编码在可执行二进制文件中，程序使用字符串切片来访问它。</p>
<p>字符串类型的变量有一个字符串数据在内存中起始位置的指针，表示有关字符串长度和容量的信息。</p>
<pre><code class="language-rust">let sentence = String::from(&quot;This is a sequence of words.&quot;);
println!(&quot;sentence is {}&quot;, sentence); // sentence is This is a sequence of words.
</code></pre>
<pre><code class="language-rust">let last_word = &amp;sentence[22..22 + 5];
println!(&quot;last_word is \&quot;{}\&quot;&quot;, last_word); // last_word is &quot;words&quot;
</code></pre>
<p><code>last_word</code> 变量有一个指向字符串数据部分的  偏移/起始 索引的指针以及切片长度。<br>
通常切片的结束索引不包含在结果中。（不包含第 5 位）</p>
<p>从起始位置到末尾的切片：</p>
<pre><code class="language-rust">let last_part: &amp;str = &amp;sentence[22..];
println!(&quot;last_part is \&quot;{}\&quot;&quot;, last_part); // last_part is &quot;words.&quot;
</code></pre>
<p>字符串切片的长度以字节数为单位，使用  <code>usize</code> 类型。<strong>不是字符串中字符的数量</strong></p>
<pre><code class="language-rust">let slice_length: usize = last_part.len();
println!(&quot;slice_length is {} bytes&quot;, slice_length); // slice_length is 6 bytes
</code></pre>
<p>当使用字符串切片索引取值的时候应特别注意，<code>UTF-8</code> 编码会占用 1 到 4 字节，而不是固定的字节。索引值必须在字符的边界处，否则程序会 <code>panic</code> 。所以在创建字符串的时候谨慎使用特殊字符或是表情。</p>
<p>在 <code>Node.js</code> 中我们是不太会关注这些底层问题。</p>
<h2 id="slices-类型作为参数">Slices 类型作为参数</h2>
<p>我们创建一个函数用来获取一句话的第一个词语：</p>
<pre><code class="language-rust">fn get_first_word(msg: &amp;String) -&gt; &amp;str {
    // 从字符串语句中创建一个字节类型的 slice （&amp;[u8]）
    let bytes: &amp;[u8] = msg.as_bytes();

    // 遍历这个 bytes ，并使用 enumerate() 获取每次的索引值
    for (index, &amp;item) in bytes.iter().enumerate() {
        // 找到第一个空格，并将之前的所有内容作为 string slice 返回
        // 一个空格的字节表示为 b' '
        // 我们正在迭代的是 字节 而不是 字符串
        // 这样做是因为 索引值 是因为字符串切片的索引是以 字节 为单位的

        if item == b' ' {
            return &amp;msg[..index];
       }
    }
    // 如果没有找到空格则返回全部
    &amp;msg
}
</code></pre>
<pre><code class="language-rust">let message = String::from(&quot;lorem ipsum&quot;);

let first_word = get_first_word(&amp;message);
println!(&quot;first_word is \&quot;{}\&quot;&quot;, first_word); // first_word is &quot;lorem&quot;

let first_word_too = get_first_word_too(&amp;message[6..]);
println!(&quot;first_word_too is \&quot;{}\&quot;&quot;, first_word_too); // first_word_too is &quot;ipsum&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 中的数组]]></title>
        <id>https://baoyuantop.github.io/post/rust-zhong-de-shu-zu/</id>
        <link href="https://baoyuantop.github.io/post/rust-zhong-de-shu-zu/">
        </link>
        <updated>2021-07-12T09:44:22.000Z</updated>
        <content type="html"><![CDATA[<p>Rust 中的数组长度是固定的，数组中的每个元素类型是一致的。</p>
<p>数组存储在内存中一段连续的空间内，<code>连续</code> 意味着相邻元素之间的距离一致。</p>
<pre><code class="language-rust">let letters = ['a', 'b', 'c']; // letters 的类型为 [char; 3]
let first_letter = letters[0];
println!(&quot;first_letter is {}&quot;, first_letter); // first_letter is a
</code></pre>
<p>如果要修改数组中的某个元素，则数组创建时应声明为 <code>可变的(mut)</code>。</p>
<pre><code class="language-rust">let mut numbers = [11, 22, 44]; // 类型为 [i32; 3]
numbers[2] = 33;
println!(&quot;numbers is {}&quot;, numbers[2]); // numbers is 33
</code></pre>
<p>声明一个空数组时，应标识类型（元素类型、长度）:</p>
<pre><code class="language-rust">let words: [&amp;str; 2]; // 标识数组长度为 2 ，元素类型为 &amp;str
words = [&quot;ok&quot;; 2]; // 重复表达式，等效于 [&quot;ok&quot;, &quot;ok&quot;]
println!(&quot;words is {:?}&quot;, words); // words is [&quot;ok&quot;, &quot;ok&quot;]
</code></pre>
<p><code>usize</code> 长度基于在目标机器 CPU 的位数：</p>
<ul>
<li>32 位机器为 4 位</li>
<li>64 位机器位 8 位</li>
</ul>
<pre><code class="language-rust">let ints = [22; 5];
let length: usize = ints.len();
println!(&quot;length is {}&quot;, length); // length is 5
</code></pre>
<p>使用 std crate 的 <code>men</code> 模块查看内存占用大小</p>
<pre><code class="language-rust">let mem_size_byte = std::mem::size_of_val(&amp;ints);
println!(&quot;mem_size_byte is {}&quot;, mem_size_byte); // mem_size_byte is 20
</code></pre>
<p>获取数组切片</p>
<pre><code class="language-rust">let mut slice: &amp;[i32] = &amp;ints;
println!(&quot;slice is {:?}&quot;, slice); // slice is [22, 22, 22, 22, 22]

slice = &amp;ints[3..5];
println!(&quot;slice is {:?}&quot;, slice); // slice is [22, 22]
</code></pre>
<h2 id="多阶数组">多阶数组</h2>
<pre><code class="language-rust">let d2: [[i32; 3]; 3] = [[9, 8, 7], [6, 5, 4], [3, 2, 1]];
let value = d2[1][0];
println!(&quot;value is {}&quot;, value); // value is 6

let d3: [[[&amp;str; 100]; 20]; 5];
d3 = [[[&quot;ok&quot;; 100]; 20]; 5];
println!(&quot;value d3[3][11][35] is {}&quot;, d3[3][11][35]) // value d3[3][11][35] is ok
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算数运算与比较运算]]></title>
        <id>https://baoyuantop.github.io/post/suan-shu-yun-suan-yu-bi-jiao-yun-suan/</id>
        <link href="https://baoyuantop.github.io/post/suan-shu-yun-suan-yu-bi-jiao-yun-suan/">
        </link>
        <updated>2021-07-12T02:59:50.000Z</updated>
        <content type="html"><![CDATA[<p>在 Rust 中只能对相同类型的操作数做算数运算。</p>
<p>基本运算:</p>
<pre><code class="language-rust">let a = 11;
let b = 33;
let c = a + b;
println!(&quot;c is {}&quot;, c); // c is 44
let d = c - b;
println!(&quot;d is {}&quot;, d); // d is 11
let e = a * d;
println!(&quot;e is {}&quot;, e); // e is 121
</code></pre>
<p>使用 <code>as</code> 进行类型转换，需要注意精度损失和兼容性问题。</p>
<pre><code class="language-rust">let f = c as f32 / 4.5;
println!(&quot;f is {}&quot;, f); // f is 9.777778
</code></pre>
<p>优先级控制</p>
<pre><code class="language-rust">let g = 43.5432 % (a as f64 * e as f64);
println!(&quot;g is {}&quot;, g); // g is 43.5432
</code></pre>
<p>同样的做比较运算只能对相同类型的进行比较</p>
<pre><code class="language-rust">let a = 11;
let b = 88;
</code></pre>
<pre><code class="language-rust">println!(&quot;a EQUAL TO b is {}&quot;, a == b); // a EQUAL TO b is false

println!(&quot;a NOT EQUAL TO b is {}&quot;, a != b); // a NOT EQUAL TO b is true

println!(&quot;a GREATER THAN b is {}&quot;, a &gt; b); // a GREATER THAN b is false

println!(&quot;a GREATER THAN OR EQUAL TO b is {}&quot;, a &gt;= b); // a GREATER THAN OR EQUAL TO b is false

println!(&quot;a LESS THAN b is {}&quot;, a &lt; b); // a LESS THAN b is true

println!(&quot;a LESS THAN OR EQUAL TO b is {}&quot;, a &lt;= b); // a LESS THAN OR EQUAL TO b is true
</code></pre>
<pre><code class="language-rust">let c = true;
let d = false;

println!(&quot;c GREATER THAN d is {}&quot;, c &gt; d); // c GREATER THAN d is true
println!(&quot;c GREATER THAN OR EQUAL TO d is {}&quot;, c &gt;= d); // c GREATER THAN OR EQUAL TO d is true
</code></pre>
<p><strong>示例：计算平均值</strong></p>
<pre><code class="language-rust">fn main() {
    let a = 33;
    let b = 4.9;
    let c: f32 = 123.5;
    let average = (a as f32 + b as f32 + c) / 3.0;
    println!(&quot;average is {}&quot;, average);
    assert_eq!(average, 53.8);
    println!(&quot;test passed.&quot;);
}
</code></pre>
<p>输出：</p>
<pre><code class="language-rust">average is 53.8
test passed.
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基本类型]]></title>
        <id>https://baoyuantop.github.io/post/ji-ben-lei-xing/</id>
        <link href="https://baoyuantop.github.io/post/ji-ben-lei-xing/">
        </link>
        <updated>2021-07-12T01:36:18.000Z</updated>
        <content type="html"><![CDATA[<p>首先定义一个判断类型的函数：</p>
<pre><code class="language-rust">fn get_type&lt;T&gt;(_: &amp;T) -&gt; &amp;str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre>
<p>关于这个函数的详细信息后面章节再做解释，现在你需要清楚它可以返回某个值的类型。</p>
<p>在 Rust 中默认的整数数字类型为 <code>i32</code>：</p>
<pre><code class="language-rust">let num1 = 123;
println!(&quot;{} - type: {}&quot;, num1, get_type(&amp;num1)); // 123 - type: i32
</code></pre>
<p>默认的浮点数字类型为 <code>f64</code>:</p>
<pre><code class="language-rust">let num2 = 1.23;
println!(&quot;{} - type: {}&quot;, num2, get_type(&amp;num2)); // 1.23 - type: f64
</code></pre>
<p>你可以显式定义某个值的类型：</p>
<pre><code class="language-rust">let num3: i8 = 23;
println!(&quot;{} - type: {}&quot;, num3, get_type(&amp;num3)); // 23 - type: i8
</code></pre>
<h2 id="最大值">最大值</h2>
<p><code>std</code> 是标准库(crate)，提供了丰富多样的功能，这里我们使用类型模块(i32、i16 等) 和属性。</p>
<pre><code class="language-rust">let max_i32 = i32::MAX;
let max_i16 = i16::MAX;
println!(&quot;max value for i32 is {}&quot;, max_i32); // max value for i32 is 2147483647
println!(&quot;max value for i16 is {}&quot;, max_i16); // max value for i16 is 32767
</code></pre>
<h2 id="布尔值">布尔值</h2>
<pre><code class="language-rust">let is_rust_fun: bool = true;
println!(
    &quot;is_rust_fun is {} - type: {}&quot;,
    is_rust_fun,
    get_type(&amp;is_rust_fun)
); // is_rust_fun is true - type: bool
let is_greater = 23 &gt; 5;
println!(
    &quot;is_greater is {} - type: {}&quot;,
    is_greater,
    get_type(&amp;is_greater)
); // is_greater is true - type: bool
</code></pre>
<h2 id="布尔值运算">布尔值运算</h2>
<p>定义两个布尔值：</p>
<pre><code class="language-rust">let a = true;
let b = false;
println!(&quot;a is {}\nb is {}&quot;, a, b);
// a is true
// b is false
</code></pre>
<p>使用 <code>!</code> 取反</p>
<pre><code class="language-rust">println!(&quot;NOT a is {}&quot;, !a); // NOT a is false
</code></pre>
<p>使用 <code>&amp;</code> 按位与，使用 <code>&amp;&amp;</code> 逻辑与</p>
<pre><code class="language-rust">println!(&quot;a AND b is {}&quot;, a &amp; b); // a AND b is false
</code></pre>
<p>使用 <code>|</code> 按位或，使用 <code>||</code> 逻辑或</p>
<pre><code class="language-rust">println!(&quot;a OR b is {}&quot;, a | b); // a OR b is true
</code></pre>
<p>使用 <code>^</code> XOR 按位异或运算</p>
<pre><code class="language-rust">println!(&quot;a XOR b is {}&quot;, a ^ b); // a XOR b is true
</code></pre>
<p>布尔类型可以映射到整数类型的 1 或 2</p>
<pre><code class="language-rust">println!(&quot;a XOR b is {}&quot;, (a ^ b) as i32); // a XOR b is 1
</code></pre>
<pre><code class="language-rust">let c = (a ^ b) | (a &amp; b);
 println!(&quot;c is {}&quot;, c); // c is true
</code></pre>
<p>短路逻辑操作，忽略右操作数</p>
<pre><code class="language-rust">let d = true || (a &amp; b);
println!(&quot;d is {}&quot;, d); // d is true
</code></pre>
<p><code>panics</code> 是一种错误处理方式，它会抛出错误栈并立即退出程序，类似于 Node.js 中的 <code>throwing error</code>。</p>
<pre><code class="language-rust">let e = false &amp;&amp; panic!();
println!(&quot;e is {}&quot;, e); // e is false
</code></pre>
<p>由于 <code>panic!()</code> 没有被执行，所以程序执行打印并正常退出。</p>
<h2 id="chars-字符">chars 字符</h2>
<p>chars 字符使用4 个字节（32位）存储:</p>
<pre><code class="language-rust">let letter: char = 'z';
let number_char = '9';
let finger = '\u{261D}';

println!(&quot;letter is {}&quot;, letter); // letter is z
println!(&quot;number_char is {}&quot;, number_char); // number_char is 9
println!(&quot;finger is {}&quot;, finger); // finger is ☝
</code></pre>
<pre><code class="language-rust">let smiley = '😀';
println!(&quot;smiley is {} - type: {}&quot;, smiley, get_type(&amp;smiley));
// smiley is 😀 - type: char
</code></pre>
<h2 id="浮点数">浮点数</h2>
<blockquote>
<ul>
<li>f32 32 位浮点数</li>
<li>f64 64 位浮点数</li>
</ul>
</blockquote>
<p>默认小数存储在 <code>f64</code> 中：</p>
<pre><code class="language-rust">let my_float = 12.345677890123456789012345;
println!(&quot;my_float is: {}&quot;, my_float);
// my_float is: 12.345677890123456
let a_float: f32 = 9.9438535983578493758;
println!(&quot;a_float is: {}&quot;, a_float);
// a_float is: 9.943853
let min_f32 = f32::MIN;
println!(&quot;min_f32 is: {}\n&quot;, min_f32);
// min_f32 is: -340282350000000000000000000000000000000

let max_f32 = f32::MAX;
println!(&quot;max_f32 is: {}\n&quot;, max_f32);
// max_f32 is: 340282350000000000000000000000000000000

let min_f64 = f64::MIN;
println!(&quot;min_f64 is: {}\n&quot;, min_f64);
// min_f64 is: -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

let max_f64 = f64::MAX;
println!(&quot;max_f64 is: {}\n&quot;, max_f64);
// max_f64 is: 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建基本项目并打印]]></title>
        <id>https://baoyuantop.github.io/post/chuang-jian-ji-ben-xiang-mu-bing-da-yin/</id>
        <link href="https://baoyuantop.github.io/post/chuang-jian-ji-ben-xiang-mu-bing-da-yin/">
        </link>
        <updated>2021-07-11T07:32:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本项目结构">基本项目结构</h2>
<p>在安装 Rust 后，使用 Cargo （Rust 的包管理器）创建一个新的项目：</p>
<pre><code class="language-bash">cargo new &lt;PROJECT_NAME&gt;
</code></pre>
<p>这会在你的当前目录中创建一个新的文件夹，或者你手动创建一个文件夹然后在文件夹内部执行：</p>
<pre><code class="language-bash">cargo init
</code></pre>
<p>项目的入口是 <code>src/main.rs</code> 文件，入口点是 <code>main</code> 函数。</p>
<p>Rust 已经为你准备好了 <code>Hello World</code> 了：</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>在项目中执行 <code>cargo run</code> 就可以看到了。</p>
<h2 id="使用-println-打印">使用 println! 打印</h2>
<p>在 Rust 中使用 <code>（macro）宏</code> 来打印到控制台，Rust 中的宏都有一个标识符，即在关键字后加一个 <code>!</code>。所以打印的宏为 <code>println!</code> ，它非常灵活：</p>
<p>字符串插值：</p>
<pre><code class="language-rust">println!(&quot;Adding {} and {} gives {}&quot;, 22, 33, 22 + 33); // Adding 22 and 33 gives 55
</code></pre>
<p>位置参数：</p>
<pre><code class="language-rust">println!(
        &quot;Ypur name is {0}. Welcome to {1}. Nice to meet you {0}&quot;,
        &quot;Goto&quot;, &quot;Rust&quot;
   ); // Ypur name is Goto. Welcome to Rust. Nice to meet you Goto
</code></pre>
<p>命名参数：</p>
<pre><code class="language-rust">println!(
        &quot;{language} is very popular. It was created in {year}&quot;,
        language = &quot;Rust&quot;,
        year = 2010
   ); // Rust is very popular. It was created in 2010
</code></pre>
<p>占位符 traits，使用位置参数避免重复</p>
<pre><code class="language-rust">println!(&quot;{0}, in binary: {0:b}, in hexadecimal: {0:x}&quot;, 11); // Decimal: 11      Binary: 1011    Hexadecimal: b
</code></pre>
<p>直接打印数组：</p>
<pre><code class="language-rust">println!(&quot;{:?}&quot;, [11, 22, 33]); // [11, 22, 33]
</code></pre>
<p>在 Rust 中必须在行尾使用 <code>;</code> ，除非他是函数的最后一行（后面会详细解释）。</p>
<h2 id="高级格式打印">高级格式打印</h2>
<p>首先我们声明几个变量:</p>
<pre><code class="language-rust">let x = 246.92385;
let y = 24.69;
let z = x / y;
</code></pre>
<p>打印具有三位精度的宏:</p>
<pre><code class="language-rust">println!(&quot;z is {:.3}&quot;, z); // z is 10.001
</code></pre>
<p>控制字符长度为 9 ，并设置预填充:</p>
<pre><code class="language-rust">println!(&quot;z is {:9.3}&quot;, z); // z is    10.001
</code></pre>
<p>使用 0 填充：</p>
<pre><code class="language-rust">println!(&quot;z is {:09.3}&quot;, z); // z is 00010.001
println!(&quot;z is {:09.3}\nx is {}&quot;, z, x); // z is 00010.001
// x is 246.92385
</code></pre>
<p>不换行：</p>
<pre><code class="language-rust">print!(&quot;y is {:09.3}\n x is {}\n&quot;, y, x);
// y is 00024.690
//  x is 246.92385
</code></pre>
<p>位置参数：</p>
<pre><code class="language-rust">println!(&quot;z is {0:05.1} and x is {1:.2}. \nx is also {1}&quot;, z, x);
// z is 010.0 and x is 246.92. 
// x is also 246.92385
</code></pre>
<blockquote>
<p>这里并没有 Rust 的安装教程，但是它很容易找到并搞定。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Rust 基础入门]]></title>
        <id>https://baoyuantop.github.io/post/rust-ji-chu-ru-men/</id>
        <link href="https://baoyuantop.github.io/post/rust-ji-chu-ru-men/">
        </link>
        <updated>2021-07-11T06:24:48.000Z</updated>
        <content type="html"><![CDATA[<p>这是一个系列，提供给 JavaScript 开发者的 Rust 翻译教程。原文在：https://itnext.io/deep-dive-into-rust-for-node-js-developers-5faace6dc71f。</p>
<p>随着 WebAssembly 的出现，现在是在现有 JavaScript/Node.js 基础上学习 Rust 的最佳时机，你可以使用他们在浏览器、服务端或是其他场景进行高性能计算。</p>
<p>将 Rust 添加到 Node.js 的技术栈中实属天作之合，因为 Rust 为 WebAssembly 提供了高级和完善的支持，而且 WebAssembly 二进制文件可以在 Node.js 上运行。</p>
<p>通过一些基础内容以及深入的学习，您将足够熟悉 Rust 并可以构建一些更为复杂的工程。</p>
<p>请注意：</p>
<p>作为一个 JavaScript 开发者，你会看到类似 <code>std::wx::yz</code> 或是 <code>&amp;xyz</code> 这样不熟悉的符号，不用担心后面都会解释。</p>
<p>与 JavaScript 相比，Rust 是一种偏底层语言，你会处理一些你从未在 JavaScript 中处理过或是关注过的一些事情。</p>
<p>请记住 Rust 是一种非常贴近硬件的系统编程语言，这意味着语言中提供的抽象概念更贴近硬件。这为高性能编程提供了强大的能力，也意味着比 JavaScript 更加复杂。</p>
<p>Rust 不会隐藏一些底层的问题，比如值是在堆还是栈上存储，并基于此允许或不允许。但是和 Node.js 一样，有许多包或者库可以让你干起活来更简单。</p>
<p>许多其他的教程都有一个问题在于，他们都是由精通 C 、C++ 或者 Linux 的人编写的，他们假设你已经知道计算机内部是如何工作的了，比如内存分配等。而对于许多 Web 开发者来说并不是这样。</p>
<p>这篇教程会始终保持简单，并站在 JavaScript 开发者的角度描述问题。</p>
<p>Rust 的学习曲线非常陡峭而且会耗费你很多时间，但这完全值得。总的来说，学习 Rust 可以让你成为更好的 JavaScript 开发者 !</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React Hooks]]></title>
        <id>https://baoyuantop.github.io/post/react-hooks/</id>
        <link href="https://baoyuantop.github.io/post/react-hooks/">
        </link>
        <updated>2020-03-30T13:30:15.000Z</updated>
        <content type="html"><![CDATA[<p><code>React Hooks</code> 是一种特殊的函数，它可以让你拿到 <code>React</code> 中的很多特性：<code>state</code>、<code>生命周期</code> 等等。<br>
在一些 <code>React</code> 的函数组件中，比如：</p>
<pre><code class="language-javascript">function Example (props) {
    return &lt;div /&gt;;
}
</code></pre>
<p>我们可能更习惯叫它 “无状态组件”，因为它没有内部状态（state），也没有生命周期函数。一般如果我们要做一个轻量的组件，只用来渲染数据，不包含自身的 <code>state</code> ，那么我们可以选择函数式组件，它可以给我们带来更好的性能。</p>
<p>一旦我们需要维护组件自身的 <code>state</code> 或是生命周期方法，函数式组件就不能很好的胜任了。我们会选择 <code>class</code> 组件。</p>
<p>我们还是拿最简单的计数器🌰看下：</p>
<p>我们先写一个 <code>class</code> 组件：</p>
<pre><code class="language-javascript">class Number extends React.component {
    constructor(props) {
        super(props);
        this.state = {
            count: 0,
        }
        this.handleClick = this.handleClick.bind(this)
    }

    handleClick (e) {
        this.setState({
            count: this.state.count + 1
        })
    }

    render () {
        return (
            &lt;div&gt;
                &lt;p&gt;{this.state.count}&lt;/p&gt;
                &lt;button onClick={this.handleClick}&gt;
                    Click me ~
                &lt;/button&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>
<p>很简单，当我们点一下按钮数字就会加一。</p>
<p>有了 React Hooks 的帮助，我们也可以在函数组件中实现这样的功能。React Hooks 中内置了一个 <code>useState</code> Hook，React 允许我们使用它在函数式组件中使用 <code>state</code>：</p>
<pre><code class="language-javascript">import React, { useState } from 'react';

function Number () {
    const [count, setCount] = useState(0)

    return (
        &lt;div&gt;
            &lt;p&gt;{count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
                Click me ~
            &lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<p>我们用这样一个函数式组件完成了相同的功能。</p>
<p>我们先从 <code>react</code> 中引入了 <code>useState</code> 这个 Hook，然后使用它初始化这个组件的 <code>state</code> ，<code>useState</code> 接受一个初始值参数，我们使用它初始化 <code>state</code>，然后使用结构赋值拿到 <code>count</code> 和 <code>setCount</code>，setCount 可以改变 count。当我们想要读取的时候，直接用 <code>count</code> 即可。</p>
<p>如果我们还需要其他 state 的话，直接定义即可：</p>
<pre><code class="language-javascript">    const [food, setFood] = useState('🍔')
    const [drink, setDrink] = useState('🍺')
    // ......
</code></pre>
<p>所以在之前如果我们编写函数式组件的时候需要使用 <code>state</code>，那么我们会将它转换为 <code>class</code> 组件，现在我们可以在现有的函数式组件中使用 <code>Hook</code> 完成。</p>
<p>React 内置了很多种 Hook 提供不同的功能，我们可以按需选用。除此之外，React 还支持自定义 Hook 。</p>
]]></content>
    </entry>
</feed>