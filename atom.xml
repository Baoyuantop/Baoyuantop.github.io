<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://baoyuantop.github.io</id>
    <title>Baoyuan</title>
    <updated>2020-01-01T06:54:35.851Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://baoyuantop.github.io"/>
    <link rel="self" href="https://baoyuantop.github.io/atom.xml"/>
    <logo>https://baoyuantop.github.io/images/avatar.png</logo>
    <icon>https://baoyuantop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Baoyuan</rights>
    <entry>
        <title type="html"><![CDATA[ES6中的 Symbol]]></title>
        <id>https://baoyuantop.github.io/post/es6-zhong-de-symbol</id>
        <link href="https://baoyuantop.github.io/post/es6-zhong-de-symbol">
        </link>
        <updated>2020-01-01T06:47:02.000Z</updated>
        <summary type="html"><![CDATA[<p>一点读书笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>一点读书笔记</p>
<!-- more -->
<h3 id="javascript-之-symbol">JavaScript 之 Symbol</h3>
<h4 id="symbol是什么">Symbol是什么</h4>
<blockquote>
<p><code>Symbol</code>是<code>ES6</code>中新引入的一种基本数据类型。<code>Symbol()</code>函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：<code>new Symbol()</code>。</p>
</blockquote>
<p>也就是说<code>Symbol</code>作为一种新的基本数据类型，我们可以使用：</p>
<pre><code class="language-javascript">let a = Symbol();
</code></pre>
<p>此时<code>a</code>便是一个<code>Symbol</code>类型的变量，它现在是独一无二的：</p>
<pre><code class="language-javascript">let b = Symbol();
a === b; //false
</code></pre>
<p>它还可以接受一个参数，我们可以给它传递一个字符串当描述，即使两个字符相同串也ok：</p>
<pre><code class="language-javascript">let symbol1 = Symbol('some');
let symbol2 = Symbol('some');
symbol1 === symbol2; //false
</code></pre>
<p>如果参数是对象的话，会先调用对象的<code>toString</code>方法来转换为字符串。<br>
也就是说每一个<code>Symbol</code>创造出来的值都是不一样的。需要注意的是不能使用<code>new</code>的方式来创建：</p>
<pre><code class="language-javascript">let c = new Symbol(); //TypeError: Symbol is not a constructor
</code></pre>
<h4 id="symbol的使用姿势">Symbol的使用姿势</h4>
<h5 id="给对象增加属性">给对象增加属性</h5>
<p>在<code>ES5</code>之前对象的属性名大多都是字符串，起名字是个难事，而且名字一多动不动重复了就出错了。而且有的时候我们拿过别人的代码，要给其中一个对象增加属性，我们也不知道怎么起名字不重复，这也是<code>ES6</code>中引入<code>Symbol</code>的根本原因。</p>
<pre><code class="language-javascript">let name = Symbol('name'); //加入 name 作为描述
let obj = {
    [name]: 'Baoyuan' //必须放在方括号之中
};
obj[name]; //'Baoyuan'
</code></pre>
<h5 id="属性名的遍历">属性名的遍历</h5>
<p>对象中的普通属性,我们可以使用<code>Object.keys()</code>、<code>for...in</code>或者<code>Object.getOwnPropertyNames()</code>来进行遍历，但是他们并不能遍历出<code>Symbol</code>类型的属性名。请注意，它并不是私有属性。我们可以使用<code>Object.getOwnPropertySymbols</code>的方法来获取指定对象的<code>Symbol</code>属性。它会返回当前对象中所有<code>Symbol</code>类型的属性的<code>Symbol</code>值的数组：</p>
<pre><code class="language-javascript">let a = Symbol('a');
let b = Symbol('b');
let c = 'c';
let obj = {
    [a]: 'a',
    [b]: 'b',
    c: 'c'
};
let objNames = Object.getOwnPropertySymbols(obj);
console.log(objNames); // [Symbol(a), Symbol(b)]
let objName = Object.getOwnPropertyNames(obj);
console.log(objName); // [&quot;c&quot;]
</code></pre>
<p>使用<code>Reflect.ownKeys</code>可以遍历到所有的属性名：</p>
<pre><code class="language-javascript">let names = Reflect.ownKeys(obj);
console.log(names); // [&quot;c&quot;, Symbol(a), Symbol(b)]
</code></pre>
<h5 id="symbol值的重复引用">Symbol值的重复引用</h5>
<p>有时候新建了一个<code>Symbol</code>值但是在其他地方我们希望再次使用，这时即使使用相同的描述符也不会产生同一个值，这时我们就需要<code>Symbol.for()</code>:</p>
<pre><code class="language-javascript">let a = Symbol.for('hello');
let b = Symbol.for('hello');
a === b; // true
</code></pre>
<p>其实这两种写法都会产生新的<code>Symbol</code>，不过不同的是<code>Symbol</code>每次都产生一个新的值，而<code>Symbol.for</code>会先查看给定的<code>key</code>值是否存在，不存在了再去新建，并且还会被登记在全局环境中供搜索。我们可以使用<code>Symbol.keyFor</code>查看一个已登记的<code>Symbol</code>值的<code>key</code>:</p>
<pre><code class="language-javascript">Symbol.keyFor(a); // &quot;hello&quot;
</code></pre>
<h4 id="ecmascript-中的定义">ECMAScript 中的定义</h4>
<p>我们先来想一下它的主要特征</p>
<ul>
<li>
<p>返回一个<code>Symbol</code>类型，并且是唯一的不会重复。</p>
</li>
<li>
<p>使用<code>new</code>操作符初始化会报错。</p>
</li>
<li>
<p>可以接受字符串参数作为标注，接受对象的时候调用对象的<code>toString</code>，即使参数相同返回的值也不同。</p>
</li>
</ul>
<p>最后查看一下<code>ECMAScript</code>定义的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-symbol-description">规范</a>。</p>
<blockquote>
<p>When Symbol is called with optional argument description, the following steps are taken:</p>
</blockquote>
<ol>
<li>If NewTarget is not undefined, throw a TypeError exception.</li>
<li>If description is undefined, let descString be undefined.</li>
<li>Else, let descString be ToString(description).</li>
<li>ReturnIfAbrupt(descString).</li>
<li>Return a new unique Symbol value whose [[Description]] value is descString.</li>
</ol>
<p>规范中指出了当我们调用<code>Symbol</code>的时候有几个步骤：</p>
<ol>
<li>
<p>如果我们使用了<code>new</code>，就报错。</p>
</li>
<li>
<p>如果没有传递参数，那么就使用<code>undefined</code>作为描述字.</p>
</li>
<li>
<p>如果传了的话就把它转换为字符串。</p>
</li>
<li>
<p>报错就返回。</p>
</li>
<li>
<p>新返回一个唯一的<code>Symbol</code>值，它的<code>[[Description]]</code>属性值为<code>descString</code>。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 数据响应式原理]]></title>
        <id>https://baoyuantop.github.io/post/vue-shu-ju-xiang-ying-shi-yuan-li</id>
        <link href="https://baoyuantop.github.io/post/vue-shu-ju-xiang-ying-shi-yuan-li">
        </link>
        <updated>2020-01-01T02:10:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Vue 的数据响应式原理是怎么实现的</p>
]]></summary>
        <content type="html"><![CDATA[<p>Vue 的数据响应式原理是怎么实现的</p>
<!-- more -->
<h3 id="vue-数据响应式原理">Vue 数据响应式原理</h3>
<h3 id="什么是数据响应式">什么是数据响应式</h3>
<blockquote>
<p>数据响应式即数据双向绑定，将<code>Model</code>绑定到<code>view</code>, 当我们用 Javascript代码更新<code>Model</code>时，<code>View</code>就会自动更新；如果用户更新了<code>View</code>, <code>Model</code>也会自动更新。</p>
</blockquote>
<h3 id="数据响应式原理">数据响应式原理</h3>
<ul>
<li>在Vue中主要是利用了 <code>Object.defineProperty()</code> 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</li>
<li>在Vue 3.0 中采用 ES6 中的 <code>Proxy</code> 对象来实现。</li>
</ul>
<h4 id="数据响应式实现">数据响应式实现</h4>
<ul>
<li>以下采用 Object.defineProperty() 来实现。</li>
</ul>
<ol>
<li>根据订阅发布者模式实现一个整体架构，包括 <code>MVVM</code> 类，<code>Vue</code>类， <code>Watcher</code>类。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
        }
        //劫持监听所有属性
        Observer () {

        }
        //解析指令
        Compile () {

        }
    }
</code></pre>
<ol start="2">
<li>实现 <code>MVVM</code> 中的由 M 到 V，将模型中的数据绑定到视图。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
<ol start="3">
<li>最后实现 V 到 M，当视图变化的时候，触发更新模型中的数据。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                    node.addEventListener('input', (function () {
                        return function () {
                            this.$data[attrVal] = node.value;   //这里更新了 ~
                        }
                    })().bind(this)); //bind不会立即执行
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
<ol start="4">
<li>同时更新相应视图。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
                let val = data[key];
                let watch = this._directive[key];
                //这里是核心 ！！！
                Object.defineProperty(this.$data, key, {
                    get: function () {
                        return val;
                    },
                    set: function (newVal) {
                        if (newVal !== val) {
                            val = newVal;
                            watch.forEach(ele =&gt; {  //ele为订阅者实例对象
                                ele.update();
                            })
                        }
                    }
                })
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                    node.addEventListener('input', (function () {
                        return function () {
                            this.$data[attrVal] = node.value;
                        }
                    })().bind(this)); //bind不会立即执行
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 的数据流]]></title>
        <id>https://baoyuantop.github.io/post/vuedeshujuliu</id>
        <link href="https://baoyuantop.github.io/post/vuedeshujuliu">
        </link>
        <updated>2020-01-01T01:05:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Vue 中的数据流</p>
]]></summary>
        <content type="html"><![CDATA[<p>Vue 中的数据流</p>
<!-- more -->
<h3 id="双向绑定">双向绑定</h3>
<p>model(数据) 和 view(视图) 之间的绑定， 任一方的更新都会触发另一方的更新。</p>
<h3 id="单向数据流">单向数据流</h3>
<p>model的更新会触发视图更新， 视图的更新堆model没什么影响。</p>
<h3 id="vue-的应用">Vue 的应用</h3>
<ul>
<li>Vue是单向数据流，不是双向绑定。</li>
<li>Vue的双向绑定不过是语法糖。</li>
<li>Object.defineProperty 是Vue底层用来做数据响应式更新的，不是双向绑定。</li>
</ul>
<h3 id="数据驱动">数据驱动</h3>
<ul>
<li>Vue 是数据驱动的视图框架，DOM跟数据是相互映射的，只有数据改变的时候视图才会做出相应的更新。</li>
<li>数据可以来自与自身的 data 属性、父元素的 prop、或者状态管理 Vuex。</li>
<li>数据改变触发视图更新有一些条件：</li>
</ul>
<blockquote>
<ol>
<li>数据必须写进 data{},这样的话会有响应式。</li>
<li>仅把对象名称写进 data{} 是没有效果的，要写上属性。</li>
<li>data{} 中的数据要写进视图中，否则不会响应式。</li>
</ol>
</blockquote>
<p>基于这些特征我们要学会操作数据，不能直接操作 DOM。</p>
<h3 id="vue响应式更新原理">Vue响应式更新原理</h3>
<ul>
<li>实例化的时候会对 data{} 下的数据进行处理，添加 getter 与 setter 的代理，以后读取写入数据都要经过代理层。使用到 Object.defineProperty.</li>
<li>组件在渲染的时候将 data{} 中用到的数据放进 Watcher。</li>
</ul>
]]></content>
    </entry>
</feed>