<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://baoyuantop.github.io</id>
    <title>Baoyuan</title>
    <updated>2020-01-01T07:14:50.917Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://baoyuantop.github.io"/>
    <link rel="self" href="https://baoyuantop.github.io/atom.xml"/>
    <logo>https://baoyuantop.github.io/images/avatar.png</logo>
    <icon>https://baoyuantop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Baoyuan</rights>
    <entry>
        <title type="html"><![CDATA[JS 函数知多少（下）]]></title>
        <id>https://baoyuantop.github.io/post/js-han-shu-zhi-duo-shao-xia</id>
        <link href="https://baoyuantop.github.io/post/js-han-shu-zhi-duo-shao-xia">
        </link>
        <updated>2020-01-01T07:11:39.000Z</updated>
        <summary type="html"><![CDATA[<p>一点读书笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>一点读书笔记</p>
<!-- more -->
<p>在<code>JavaScript</code>中执行一段代码的时候，它会创建出对应的执行上下文。作为一个重要的概念，它定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。对于每一个执行上下文，都有三个重要的属性：</p>
<ul>
<li>变量对象</li>
<li>作用域链</li>
<li>this</li>
</ul>
<h4 id="变量对象">变量对象</h4>
<p>每个执行上下文都有一个与之对应的变量对象，它存储了在上下文中定义的变量和函数声明。当然在全局上下文中的变量对象就是全局对象了。</p>
<p>在处理一个执行上下文时有两个过程：</p>
<ol>
<li>进入该执行上下文</li>
</ol>
<p>这个时候是还没有执行代码，其中的变量对象中主要是函数的所有形参、函数声明和对象声明。</p>
<ol start="2">
<li>执行代码</li>
</ol>
<p>这个时候代码会顺序执行，然后根据实际情况来修改变量对象。</p>
<p>举个栗子：</p>
<pre><code class="language-javascript">function demo(a) {
    var b = 2;
    function c() {};
    var d = function () {};
    b = 3;
}
demo(1);
</code></pre>
<p>在刚进入这个执行上下文的时候，变量对象是这样的：</p>
<pre><code class="language-javascript">AO = {
    arguments: {
        0: 3;
        length: 1;
    },
    a: 1,
    b: undefined,
    c: reference to function c() {},
    d: undefined
}
</code></pre>
<p>当开始执行代码的时候就是这样的：</p>
<pre><code class="language-javascript">AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c() {},
    d: reference to function d() {}
    
}
</code></pre>
<h4 id="作用域链">作用域链</h4>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6">计算机</a><a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">程序设计</a>中，<strong>作用域</strong>（scope，或译作有效范围）是名字（name）与实体（entity）的绑定（binding）保持有效的那部分计算机程序。不同的<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>可能有不同的<strong>作用域</strong>和<a href="https://zh.wikipedia.org/w/index.php?title=%E5%90%8D%E5%AD%97%E8%A7%A3%E6%9E%90&amp;action=edit&amp;redlink=1">名字解析</a>。而同一语言内也可能存在多种<strong>作用域</strong>，随<a href="https://zh.wikipedia.org/wiki/%E5%AF%A6%E9%AB%94">实体</a>的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B">类型</a>变化而不同。<strong>作用域类别</strong>影响<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F">变量</a>的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A&amp;action=edit&amp;redlink=1">绑定</a>方式，根据语言使用<strong>静态作用域</strong>还是<strong>动态作用域</strong><a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F">变量</a>的取值可能会有不同的结果。</p>
<p>--维基百科</p>
</blockquote>
<p><code>JavaScript</code>在执行程序需要查找一个变量的时候，首先它会查看当前的执行上下文的变量对象，没有找到的话就去父级执行上下文的变量对象，要是还没有就去全局变量对象，直到找到。由多个执行上下文的变量对象构成的链表就是作用域链。</p>
<p>函数的作用域链在它创建的时候就决定了。在函数内部都有一个<code>scope</code>的属性，当我们创建的时候它就会把所有的父级的变量对象存储在里面。但是这并不是一条完整的作用域链，只有当程序进入该执行上下文，会把当前的变量对象添加到最前端，这是才是一条完整的作用域链。</p>
<h4 id="this">this</h4>
<p>简单看下<code>this</code>:</p>
<pre><code class="language-javascript">function demo() {
    console.log(this.a);
};
var a = 1;
demo();

const obj = {
    a: 1,
    fun: demo
};
obj.demo();

const c = new demo();
</code></pre>
<p>对于直接调用函数<code>demo()</code>，里面的<code>this</code>则直接指向了<code>window</code>。而当对象<code>obj</code>来调用这个函数，那么<code>this</code>此时则就代表该对象。也就是谁调用就代表谁。而在最后使用<code>new</code>的话<code>this</code>就被永远绑在了<code>c</code>上面。而对于特殊的箭头函数，它本身没有<code>this</code>，它取决于包裹箭头函数的第一个普通函数。</p>
<p>使用<code>bind()</code>函数可以改变<code>this</code>的指向，它会创建一个新的函数并将<code>this</code>绑定传入的参数。</p>
<pre><code class="language-javascript">var obj = {
    a: 1,
    getA: function () {
        return this.a;
    }
};
var b = obj.getA.bind(obj);
console.log(b); // 1
</code></pre>
<p>当然这对箭头函数是无效的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 函数知多少]]></title>
        <id>https://baoyuantop.github.io/post/js-han-shu-zhi-duo-shao</id>
        <link href="https://baoyuantop.github.io/post/js-han-shu-zhi-duo-shao">
        </link>
        <updated>2020-01-01T06:59:58.000Z</updated>
        <summary type="html"><![CDATA[<p>一点读书笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>一点读书笔记</p>
<!-- more -->
<h3 id="js函数知多少上">JS函数知多少(上)</h3>
<p>说起来<code>JavaScript</code>中最有意思的东西，莫过于函数了。</p>
<p>函数在任何一种编程语言中应该都存在，可以将经常使用的代码封装起来，在需要的地方多次调用。在<code>JavaScript</code>中也是这个意思，不过它还有他自己独特的地方。</p>
<p><code>Function</code>作为一种引用类型，每个函数都是<code>Function</code>类型的实例，定义：</p>
<pre><code class="language-javascript">function functionName (argnments) {
    // something...
};
</code></pre>
<p>你也可以使用函数表达式：</p>
<pre><code class="language-javascript">let fun = function (argument) {
    // something...
};
</code></pre>
<p>使用这种方式的时候不用写函数名，使用<code>fun</code>即可引用。这两种方式几乎相差无几。</p>
<p>它具有引用类型的属性与方法。所以本质上函数是对象。你可能没见过这样的操作：</p>
<pre><code class="language-javascript">let addNum = new Function('num1', 'num2', 'return num1+num2');
</code></pre>
<p>上面这个实际上是定义了一个函数，接受两个参数，返回两个数字的和。很形象的表现了对象的本质，但是实际使用的时候不推荐这样写。</p>
<p>因为是以对象为形式在内存中存储的，所以函数的名字本质上只是一个指向函数的指针，这样的话一个函数也可以有多个名字了，只是多个指针引用了同一个对象。我们也可以通过给某个名字赋值<code>null</code>来解除这种引用。这种特性引出了<code>JS</code>函数的一个特点：<code>没有重载</code>。因为当你创建第二个相同名字的函数的时候就把第一个引用给覆盖掉了。</p>
<p>函数是可以作为值来引用的，你可以给函数传递参数的时候传递一个函数，你也可以在返回值的时候返回一个函数，这在某些场景下是十分有用的。</p>
<p>在函数中有两个属性需要注意下：</p>
<h4 id="arguments">arguments</h4>
<p>它是一个跟数组差不多的对象，保存着传进函数的所有参数，我们可以很方便的查看，进行一些操作。比如根据传入参数的情况判断对应的操作。</p>
<h4 id="this">this</h4>
<p>当初设计<code>js</code>的时候被迫进行模仿<code>Java</code>，所以这个特性跟<code>Java</code>中的类似。<code>this</code>引用的是函数执行的环境对象。这个要看具体的情况具体分析。比如当在网页的全局环境下调用函数的话，<code>this</code>对象引用的就是<code>window</code>。它可以在代码的执行过程中引用不同的对象。</p>
<p>不过还需要注意一个特殊的类别：箭头函数。箭头函数是没有<code>this</code>的，它的这个属性只取决于包裹箭头函数的第一个普通函数的<code>this</code>。</p>
<p>下一篇从作用域角度再详细说明。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6中的 Symbol]]></title>
        <id>https://baoyuantop.github.io/post/es6-zhong-de-symbol</id>
        <link href="https://baoyuantop.github.io/post/es6-zhong-de-symbol">
        </link>
        <updated>2020-01-01T06:47:02.000Z</updated>
        <summary type="html"><![CDATA[<p>一点读书笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>一点读书笔记</p>
<!-- more -->
<h3 id="javascript-之-symbol">JavaScript 之 Symbol</h3>
<h4 id="symbol是什么">Symbol是什么</h4>
<blockquote>
<p><code>Symbol</code>是<code>ES6</code>中新引入的一种基本数据类型。<code>Symbol()</code>函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：<code>new Symbol()</code>。</p>
</blockquote>
<p>也就是说<code>Symbol</code>作为一种新的基本数据类型，我们可以使用：</p>
<pre><code class="language-javascript">let a = Symbol();
</code></pre>
<p>此时<code>a</code>便是一个<code>Symbol</code>类型的变量，它现在是独一无二的：</p>
<pre><code class="language-javascript">let b = Symbol();
a === b; //false
</code></pre>
<p>它还可以接受一个参数，我们可以给它传递一个字符串当描述，即使两个字符相同串也ok：</p>
<pre><code class="language-javascript">let symbol1 = Symbol('some');
let symbol2 = Symbol('some');
symbol1 === symbol2; //false
</code></pre>
<p>如果参数是对象的话，会先调用对象的<code>toString</code>方法来转换为字符串。<br>
也就是说每一个<code>Symbol</code>创造出来的值都是不一样的。需要注意的是不能使用<code>new</code>的方式来创建：</p>
<pre><code class="language-javascript">let c = new Symbol(); //TypeError: Symbol is not a constructor
</code></pre>
<h4 id="symbol的使用姿势">Symbol的使用姿势</h4>
<h5 id="给对象增加属性">给对象增加属性</h5>
<p>在<code>ES5</code>之前对象的属性名大多都是字符串，起名字是个难事，而且名字一多动不动重复了就出错了。而且有的时候我们拿过别人的代码，要给其中一个对象增加属性，我们也不知道怎么起名字不重复，这也是<code>ES6</code>中引入<code>Symbol</code>的根本原因。</p>
<pre><code class="language-javascript">let name = Symbol('name'); //加入 name 作为描述
let obj = {
    [name]: 'Baoyuan' //必须放在方括号之中
};
obj[name]; //'Baoyuan'
</code></pre>
<h5 id="属性名的遍历">属性名的遍历</h5>
<p>对象中的普通属性,我们可以使用<code>Object.keys()</code>、<code>for...in</code>或者<code>Object.getOwnPropertyNames()</code>来进行遍历，但是他们并不能遍历出<code>Symbol</code>类型的属性名。请注意，它并不是私有属性。我们可以使用<code>Object.getOwnPropertySymbols</code>的方法来获取指定对象的<code>Symbol</code>属性。它会返回当前对象中所有<code>Symbol</code>类型的属性的<code>Symbol</code>值的数组：</p>
<pre><code class="language-javascript">let a = Symbol('a');
let b = Symbol('b');
let c = 'c';
let obj = {
    [a]: 'a',
    [b]: 'b',
    c: 'c'
};
let objNames = Object.getOwnPropertySymbols(obj);
console.log(objNames); // [Symbol(a), Symbol(b)]
let objName = Object.getOwnPropertyNames(obj);
console.log(objName); // [&quot;c&quot;]
</code></pre>
<p>使用<code>Reflect.ownKeys</code>可以遍历到所有的属性名：</p>
<pre><code class="language-javascript">let names = Reflect.ownKeys(obj);
console.log(names); // [&quot;c&quot;, Symbol(a), Symbol(b)]
</code></pre>
<h5 id="symbol值的重复引用">Symbol值的重复引用</h5>
<p>有时候新建了一个<code>Symbol</code>值但是在其他地方我们希望再次使用，这时即使使用相同的描述符也不会产生同一个值，这时我们就需要<code>Symbol.for()</code>:</p>
<pre><code class="language-javascript">let a = Symbol.for('hello');
let b = Symbol.for('hello');
a === b; // true
</code></pre>
<p>其实这两种写法都会产生新的<code>Symbol</code>，不过不同的是<code>Symbol</code>每次都产生一个新的值，而<code>Symbol.for</code>会先查看给定的<code>key</code>值是否存在，不存在了再去新建，并且还会被登记在全局环境中供搜索。我们可以使用<code>Symbol.keyFor</code>查看一个已登记的<code>Symbol</code>值的<code>key</code>:</p>
<pre><code class="language-javascript">Symbol.keyFor(a); // &quot;hello&quot;
</code></pre>
<h4 id="ecmascript-中的定义">ECMAScript 中的定义</h4>
<p>我们先来想一下它的主要特征</p>
<ul>
<li>
<p>返回一个<code>Symbol</code>类型，并且是唯一的不会重复。</p>
</li>
<li>
<p>使用<code>new</code>操作符初始化会报错。</p>
</li>
<li>
<p>可以接受字符串参数作为标注，接受对象的时候调用对象的<code>toString</code>，即使参数相同返回的值也不同。</p>
</li>
</ul>
<p>最后查看一下<code>ECMAScript</code>定义的<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-symbol-description">规范</a>。</p>
<blockquote>
<p>When Symbol is called with optional argument description, the following steps are taken:</p>
</blockquote>
<ol>
<li>If NewTarget is not undefined, throw a TypeError exception.</li>
<li>If description is undefined, let descString be undefined.</li>
<li>Else, let descString be ToString(description).</li>
<li>ReturnIfAbrupt(descString).</li>
<li>Return a new unique Symbol value whose [[Description]] value is descString.</li>
</ol>
<p>规范中指出了当我们调用<code>Symbol</code>的时候有几个步骤：</p>
<ol>
<li>
<p>如果我们使用了<code>new</code>，就报错。</p>
</li>
<li>
<p>如果没有传递参数，那么就使用<code>undefined</code>作为描述字.</p>
</li>
<li>
<p>如果传了的话就把它转换为字符串。</p>
</li>
<li>
<p>报错就返回。</p>
</li>
<li>
<p>新返回一个唯一的<code>Symbol</code>值，它的<code>[[Description]]</code>属性值为<code>descString</code>。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 数据响应式原理]]></title>
        <id>https://baoyuantop.github.io/post/vue-shu-ju-xiang-ying-shi-yuan-li</id>
        <link href="https://baoyuantop.github.io/post/vue-shu-ju-xiang-ying-shi-yuan-li">
        </link>
        <updated>2020-01-01T02:10:33.000Z</updated>
        <summary type="html"><![CDATA[<p>Vue 的数据响应式原理是怎么实现的</p>
]]></summary>
        <content type="html"><![CDATA[<p>Vue 的数据响应式原理是怎么实现的</p>
<!-- more -->
<h3 id="vue-数据响应式原理">Vue 数据响应式原理</h3>
<h3 id="什么是数据响应式">什么是数据响应式</h3>
<blockquote>
<p>数据响应式即数据双向绑定，将<code>Model</code>绑定到<code>view</code>, 当我们用 Javascript代码更新<code>Model</code>时，<code>View</code>就会自动更新；如果用户更新了<code>View</code>, <code>Model</code>也会自动更新。</p>
</blockquote>
<h3 id="数据响应式原理">数据响应式原理</h3>
<ul>
<li>在Vue中主要是利用了 <code>Object.defineProperty()</code> 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。</li>
<li>在Vue 3.0 中采用 ES6 中的 <code>Proxy</code> 对象来实现。</li>
</ul>
<h4 id="数据响应式实现">数据响应式实现</h4>
<ul>
<li>以下采用 Object.defineProperty() 来实现。</li>
</ul>
<ol>
<li>根据订阅发布者模式实现一个整体架构，包括 <code>MVVM</code> 类，<code>Vue</code>类， <code>Watcher</code>类。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
        }
        //劫持监听所有属性
        Observer () {

        }
        //解析指令
        Compile () {

        }
    }
</code></pre>
<ol start="2">
<li>实现 <code>MVVM</code> 中的由 M 到 V，将模型中的数据绑定到视图。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
<ol start="3">
<li>最后实现 V 到 M，当视图变化的时候，触发更新模型中的数据。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                    node.addEventListener('input', (function () {
                        return function () {
                            this.$data[attrVal] = node.value;   //这里更新了 ~
                        }
                    })().bind(this)); //bind不会立即执行
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
<ol start="4">
<li>同时更新相应视图。</li>
</ol>
<pre><code class="language-Javascript">    //发布者
    class Vue {
        constructor (options) {
            this.options = options;
            this.$data = options.data; //获取数据
            this.$el = document.querySelector(options.el); //获取挂载对象
            this._directive = {}; //创建容器存放订阅者
            this.Observer(this.$data);
            this.Compile(this.$el);
        }
        //劫持监听所有属性
        Observer (data) {
            for (let key in data) {
                this._directive[key] = [];
                let val = data[key];
                let watch = this._directive[key];
                //这里是核心 ！！！
                Object.defineProperty(this.$data, key, {
                    get: function () {
                        return val;
                    },
                    set: function (newVal) {
                        if (newVal !== val) {
                            val = newVal;
                            watch.forEach(ele =&gt; {  //ele为订阅者实例对象
                                ele.update();
                            })
                        }
                    }
                })
            }
        }
        //解析指令
        Compile (el) {
            let Vnodes = el.children;
            for (Vnode of Vnodes) {
                //递归查找子元素
                if (Vnode.children.length) {
                    this.Compile(Vnode);
                }
                //判断是否含有对应的属性，做出相应的处理
                if (Vnode.hasAttribute('v-text')) {
                    let attrVal = node.getAttribute('v-text');
                    //向订阅者容器中添加对应的订阅者
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'innerHTML'));
                }
                if (Vnode.hasAttribute('v-model')) {
                    let attrVal = node.getAttribute('v-model');
                    this._directive[attrVal].push(new Watcher(node, this, attrVal, 'value'));
                    node.addEventListener('input', (function () {
                        return function () {
                            this.$data[attrVal] = node.value;
                        }
                    })().bind(this)); //bind不会立即执行
                }
            }
        }
        //订阅者,更新视图
        class Watcher {
            constructor (el, vm, exp, attr) {
                this.el = el;
                this.vm = vm;
                this.exp = exp;
                this.attr = attr;
                this.update(); //初始化视图
            }
            update () {
                this.el[this.attr] = this.vm.$data[this.exp];
            }
        }
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue 的数据流]]></title>
        <id>https://baoyuantop.github.io/post/vuedeshujuliu</id>
        <link href="https://baoyuantop.github.io/post/vuedeshujuliu">
        </link>
        <updated>2020-01-01T01:05:40.000Z</updated>
        <summary type="html"><![CDATA[<p>Vue 中的数据流</p>
]]></summary>
        <content type="html"><![CDATA[<p>Vue 中的数据流</p>
<!-- more -->
<h3 id="双向绑定">双向绑定</h3>
<p>model(数据) 和 view(视图) 之间的绑定， 任一方的更新都会触发另一方的更新。</p>
<h3 id="单向数据流">单向数据流</h3>
<p>model的更新会触发视图更新， 视图的更新堆model没什么影响。</p>
<h3 id="vue-的应用">Vue 的应用</h3>
<ul>
<li>Vue是单向数据流，不是双向绑定。</li>
<li>Vue的双向绑定不过是语法糖。</li>
<li>Object.defineProperty 是Vue底层用来做数据响应式更新的，不是双向绑定。</li>
</ul>
<h3 id="数据驱动">数据驱动</h3>
<ul>
<li>Vue 是数据驱动的视图框架，DOM跟数据是相互映射的，只有数据改变的时候视图才会做出相应的更新。</li>
<li>数据可以来自与自身的 data 属性、父元素的 prop、或者状态管理 Vuex。</li>
<li>数据改变触发视图更新有一些条件：</li>
</ul>
<blockquote>
<ol>
<li>数据必须写进 data{},这样的话会有响应式。</li>
<li>仅把对象名称写进 data{} 是没有效果的，要写上属性。</li>
<li>data{} 中的数据要写进视图中，否则不会响应式。</li>
</ol>
</blockquote>
<p>基于这些特征我们要学会操作数据，不能直接操作 DOM。</p>
<h3 id="vue响应式更新原理">Vue响应式更新原理</h3>
<ul>
<li>实例化的时候会对 data{} 下的数据进行处理，添加 getter 与 setter 的代理，以后读取写入数据都要经过代理层。使用到 Object.defineProperty.</li>
<li>组件在渲染的时候将 data{} 中用到的数据放进 Watcher。</li>
</ul>
]]></content>
    </entry>
</feed>